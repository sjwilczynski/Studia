import Data.List


type Result = ([Int], [((Int, Int), (Int, Int))])
type Plansza = [[Int]]
type Rozmiar = Int
type Para = (Int,Int)

generuj :: Rozmiar -> (Int,Int) -> [[Int]]
generuj 0 _ = [[]]
generuj n (min,max) = [(x:xs)| x <- [min..max], xs <- generuj (n-1) (x,99 `div` x), (n < 2)||(x*(head xs) > 9) ] 

--cel:
--solve :: Int -> [[Int]] -> [Result]
--solve n tab = [ (xs,ys)| let g = generuj n (1,99), xs <- g, ys <- iloczyny (n,tab,[]) xs]

sasiad :: Rozmiar -> Para -> [Para]
sasiad n (x,y) = [(x+a,y+b)| a <- [-1..1], b <- [-1..1], (x+a)>0, (y+b)>0, (a /= 0) || (b /= 0), (n-1) >= (x+a), n >= (y+b) ]

wartosc :: Para -> Plansza -> Int
wartosc (a,b) xs = ys !! (b-1)
	where ys = xs !! (a-1) 

iloczyny :: (Rozmiar,Plansza,[Para]) -> [Int] -> [(Para, Para)]
iloczyny _ [] = []
iloczyny (n,tab,visit) (g1:gen) =  xs ++ ys
	 where xs = map (head.iloczyn (n,tab,visit) g1) gen
	       aux = unzip xs
	       nvisit = visit ++ (fst aux) ++ (snd aux) 
	       ys = iloczyny (n,tab,nvisit) gen

--iloczyny _ [] = [[]]
--iloczyny (n,tab,visit) (g1:gen) = [ xs++ys| xs po jednym elemencie z kazdego iloczyn, f xs - tak zeby visit sie zgadzalo, let aux = unzip xs, let nvisit = visit ++ (fst aux) ++ (snd aux), ys <- iloczyny (n,tab,nvisit) gen] 
iloczyny2 :: (Rozmiar,Plansza,[Para]) -> [Int] -> [[(Para, Para)]]
iloczyny2 _ [] = [[]]
iloczyny2 (n,tab,visit) (g1:gen) = [ xs++ys| xs <- wybierz$ map (iloczyn (n,tab,visit) g1) gen, 
					let aux = unzip xs, let nvisit = visit ++ (fst aux) ++ (snd aux), 
					ys <- iloczyny2 (n,tab,nvisit) gen] 
	   
--czy ta funkcja generuje wszytskie pary	
iloczyn :: (Rozmiar,Plansza,[Para]) -> Int -> Int -> [(Para, Para)]
iloczyn (n,tab,visit) x y = [((a,b),(c,d))| a <- [1..n-1], b <- [1..n], c <- [1..n-1], d <- [1..n],
				      let t1 = (a,b) `elem` visit,
				      let t2 = (c,d) `elem` visit,
				      (not t1) && (not t2),
				      (c,d) `elem` sasiad n (a,b), 
				      let v1 = wartosc (a,b) tab,
				      let v2 = wartosc (c,d) tab,
				      10*v1 + v2 == x*y]
wybierz :: [[(Para,Para)]] -> [[(Para,Para)]]
wybierz [] = [[]]
wybierz (x:xs) = [(a,b):ys| (a,b) <- x, ys <- wybierz xs, let zs = fst(unzip ys) ++ snd(unzip ys),
							let t1 = a `elem` zs, 
						      let t2 = b `elem` zs, (not t1) && (not t2)]


iloczyn2 :: (Rozmiar,Plansza,[Para]) -> Int -> Int -> Maybe [(Para, Para)]
iloczyn2 (n,tab,visit) x y 
		| length xs > 0 = Just xs
		| otherwise = Nothing
		where xs = [((a,b),(c,d))| a <- [1..n-1], b <- [1..n], c <- [1..n-1], d <- [1..n],
				      let t1 = (a,b) `elem` visit,
				      let t2 = (c,d) `elem` visit,
				      (not t1) && (not t2),
				      (c,d) `elem` sasiad n (a,b), 
				      let v1 = wartosc (a,b) tab,
				      let v2 = wartosc (c,d) tab,
				      10*v1 + v2 == x*y]







