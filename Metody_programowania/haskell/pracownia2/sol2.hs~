import Puzzle
import Checker
import Data.List

type Plansza = [[Int]]
type Rozmiar = Int
type Para = (Int,Int)

solve :: Rozmiar -> Plansza -> [Result] 
solve n tab = [  fst x | x <- rozwiaz( n,tab,[],[],[],(1,99) )]

rozwiaz :: (Rozmiar,Plansza,[Int],[(Para,Para)],[Para],(Int,Int)) -> [(Result,[Para])]
rozwiaz(n,tab,tg,tw,tv,(min,max)) 
		| length tg == n = [((tg,tw),tv)]
		| otherwise = concat [ rozwiaz(n,tab,(x:tg),(xs++tw),(ys++tv),(10 `div` x + 1, mniejsze x (99 `div` x)))| 
					x <- [max,max-1..min], 
					xs <- wybierz$ map (iloczyn (n,tab,tv) x) tg,
					let aux = unzip xs, let ys = tv ++ (fst aux) ++ (snd aux)]

iloczyn :: (Rozmiar,Plansza,[Para]) -> Int -> Int -> [(Para, Para)]
iloczyn (n,tab,visit) x y = [((a,b),(c,d))| a <- [1..n-1], b <- [1..n], c <- [1..n-1], d <- [1..n],
				      let v1 = wartosc (a,b) tab,
				      let v2 = wartosc (c,d) tab,
				      10*v1 + v2 == x*y,
				      let t1 = (a,b) `elem` visit, not t1,
				      let t2 = (c,d) `elem` visit, not t2,
				      (c,d) `elem` sasiad n (a,b)]

wybierz :: [[(Para,Para)]] -> [[(Para,Para)]]
wybierz [] = [[]]
wybierz (x:xs) = [(a,b):ys| (a,b) <- x, ys <- wybierz xs, let zs = fst(unzip ys) ++ snd(unzip ys),
							let t1 = a `elem` zs, not t1,
						      let t2 = b `elem` zs, not t2]
					
sasiad :: Rozmiar -> Para -> [Para]
sasiad n (x,y) = [(x+a,y+b)| a <- [-1..1], b <- [-1..1], (x+a)>0, (y+b)>0, (a /= 0) || (b /= 0), (n-1) >= (x+a), n >= (y+b) ]

wartosc :: Para -> Plansza -> Int
wartosc (a,b) xs = ys !! (b-1)
	where ys = xs !! (a-1) 

mniejsze :: Int -> Int -> Int
mniejsze x y 
	| x < y = x
	|otherwise = y

--solve :: Int -> [[Int]] -> [Result]
--solve n tab = [ (xs,ys)| let g = generuj n (1,99), xs <- g, ys <- iloczyny2 (n,tab,[]) xs]
--iloczyny2 :: (Rozmiar,Plansza,[Para]) -> [Int] -> [[(Para, Para)]]
--iloczyny2 _ [] = [[]]
--iloczyny2 (n,tab,visit) (g1:gen) = [ xs++ys| xs <- wybierz$ map (iloczyn (n,tab,visit) g1) gen, 
					--let aux = unzip xs, let nvisit = visit ++ (fst aux) ++ (snd aux), 
					--ys <- iloczyny2 (n,tab,nvisit) gen]
--generuj :: Rozmiar -> (Int,Int) -> [[Int]]
--generuj 0 _ = [[]]
--generuj n (min,max) = [(x:xs)| x <- [min..max], xs <- generuj (n-1) (x,99 `div` x), (n < 2)||(x*(head xs) > 9) ]  


tests :: [Test]
tests = [
		SimpleTest
          (Puzzle 2 [[9, 6]])
          ([3, 23], [ ((1, 2), (1, 1))])
		,SimpleTest
          (Puzzle 3 [[8,6,8],[1,4,9]])
          ([3, 6, 16], [ ((2, 1), (1, 1)), ((2, 2), (1, 3)), ((2, 3), (1, 2))])
		,SimpleTest
          (Puzzle 3 [[1,3,4],[3,2,4]])
          ([3, 4, 11], [ ((1, 1), (2, 2)), ((1, 2), (2, 1)), ((1, 3), (2, 3))])
		,SimpleTest
          (Puzzle 3 [[6,4,0],[0,9,6]])
          ([5, 8, 12], [ ((1, 2), (2, 1)), ((2, 3), (1, 3)), ((2, 2), (1, 1))])
		,SimpleTest
          (Puzzle 4 [[9,5,1,5],[6,3,3,2],[9,1,5,1]])
          ([3, 5, 7, 13], [ ((1, 3), (1, 4)), ((2, 4), (3, 4)), ((2, 2), (1, 1)), ((2, 3), (3, 3)), ((2, 1), (1, 2)), ((3, 1), (3, 2))])
		,SimpleTest
          (Puzzle 4 [[4,9,2,8],[4,7,9,6],[7,6,3,3]])
          ([4, 7, 9, 11], [ ((1, 3), (1, 4)), ((3, 3), (3, 2)), ((1, 1), (2, 1)), ((2, 4), (3, 4)), ((2, 2), (3, 1)), ((1, 2), (2, 3))])
		,SimpleTest
          (Puzzle 4 [[9,5,1,5],[6,3,3,2],[9,1,5,1]])
          ([3, 5, 7, 13], [ ((3, 4), (3, 3)), ((2, 4), (1, 3)), ((2, 2), (1, 1)), ((2, 3), (1, 4)), ((2, 1), (1, 2)), ((3, 1), (3, 2))])
		,SimpleTest
          (Puzzle 5 [[9,8,2,6,8],[1,6,1,4,4],[4,2,1,2,9],[3,6,8,6,4]])
          ([3, 4, 6, 6, 16], [ ((2, 3), (1, 3)), ((3, 3), (4, 3)), ((2, 1), (1, 2)), ((2, 5), (1, 5)), ((3, 4), (4, 5)), 
		((3, 2), (3, 1)), ((1, 4), (2, 4)), ((4, 1), (4, 2)), ((3, 5), (4, 4)), ((1, 1), (2, 2))])
		,SimpleTest
          (Puzzle 5 [[4,6,9,8,4],[1,8,2,2,3],[8,7,1,6,4],[4,2,6,5,2]])
          ([3, 6, 7, 8, 12], [ ((2, 1), (3, 1)), ((2, 4), (3, 3)), ((4, 2), (4, 1)), ((2, 5), (3, 4)), ((3, 5), (4, 5)), 
		((1, 1), (2, 2)), ((3, 2), (2, 3)), ((4, 4), (4, 3)), ((1, 4), (1, 5)), ((1, 3), (1, 2))])
		,SimpleTest
          (Puzzle 6 [[2,6,4,2,3,2],[5,3,0,4,0,1],[1,0,2,7,0,7],[2,9,8,6,7,6],[0,2,8,3,3,2]])
          ([3, 4, 7, 8, 9, 10], [ ((2, 6), (1, 6)), ((4, 1), (3, 1)), ((1, 4), (2, 4)), ((5, 6), (4, 5)), ((1, 5), (2, 5)), 
		((5, 2), (5, 3)), ((2, 2), (1, 1)), ((5, 5), (4, 6)), ((1, 3), (2, 3)), ((2, 1), (1, 2)), ((4, 4), (5, 4))
		, ((3, 6), (3, 5)), ((3, 4), (3, 3)), ((4, 3), (3, 2)), ((4, 2), (5, 1))])
		,CountTest
          (Puzzle 3 [[8,2,6], [0,4,0]])
          2
		,CountTest
          (Puzzle 3 [[4,2,5], [0,4,5]])
          4
		,CountTest
          (Puzzle 4 [[5,2,8,6],[6,2,3,5],[9,4,8,2]])
          12
		,CountTest
          (Puzzle 4 [[2,2,9,8],[4,8,4,8],[1,2,1,4]])
          11
		,CountTest
          (Puzzle 5 [[4,4,4,4,4],[4,4,4,4,4],[5,5,5,5,5],[6,6,6,6,6]])
          0
		,CountTest
          (Puzzle 5 [[6,0,2,4,0],[0,6,4,3,2],[8,1,8,2,1],[6,3,1,4,0]])
          32
		,CountTest
          (Puzzle 6 [[2,6,4,2,3,2],[5,3,0,4,0,1],[1,0,2,7,0,7],[2,9,8,6,7,6],[0,2,4,3,3,2]])
          0
	]

main :: IO ()
main = checkerMain solve tests
